%! Tex program = xelatex
\documentclass{article}

%中文
%\usepackage[UTF8]{ctex}
%数学公式
\usepackage{amsmath,amssymb}
%\usepackage{ntheorem}
\usepackage{amsthm}
%边界
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}%table package
%Table
\usepackage{multirow,booktabs}
\usepackage{makecell}
%字体颜色
\usepackage{color}
\usepackage[dvipsnames]{xcolor}  % 更全的色系
%代码
\usepackage[OT1]{fontenc}
% MATLAB 代码风格
\usepackage[framed,numbered,autolinebreaks,useliterate]{/Users/anye_zhenhaoyu/Desktop/Latex/mcode}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{pythonhighlight} % Python
%插图
\usepackage{graphicx}
%改变item格式
\usepackage{enumerate}
%物理
\usepackage{physics}
%extra arrows
\usepackage{extarrows}
% caption（居中指令）
%\usepackage[justification=centering]{caption}
\usepackage{caption}
% htpb
\usepackage{stfloats}
% pdf 拼接
\usepackage{pdfpages}
% 超链接url
\usepackage{url}

\def\RR{\mathbb{R}}
\def\ZZ{\mathbb{Z}}
\def\EE{\mathbb{E}}

\def\Trsp#1{#1^{\mathcal{T}}}

\def\bold#1{\boldsymbol{#1}}
\def\bw{\boldsymbol{\omega}}
\def\ba{\boldsymbol{a}}
\def\bb{\boldsymbol{b}}
\def\bc{\boldsymbol{c}}
\def\bd{\boldsymbol{d}}
\def\be{\boldsymbol{e}}
\def\bf{\boldsymbol{f}}
\def\bg{\boldsymbol{g}}
\def\bt{\boldsymbol{t}}
\def\bu{\boldsymbol{u}}
\def\bv{\boldsymbol{v}}
\def\bx{\boldsymbol{x}}
\def\by{\boldsymbol{y}}
\def\bz{\boldsymbol{z}}

\def\bA{\boldsymbol{A}}
\def\bB{\boldsymbol{B}}
\def\bC{\boldsymbol{C}}
\def\bE{\boldsymbol{E}}
\def\bL{\boldsymbol{L}}
\def\bM{\boldsymbol{M}}
\def\bO{\boldsymbol{O}}
\def\bP{\boldsymbol{P}}
\def\bQ{\boldsymbol{Q}}
\def\bX{\boldsymbol{X}}
\def\bY{\boldsymbol{Y}}

\def\Esolve{\textcolor{blue}{Solve: }}
\def\Eproof{\textcolor{blue}{Proof: }}
\def\case#1{\textcolor{blue}{Case \uppercase\expandafter{\romannumeral#1}: }}

\def\suminf#1{\sum_{#1=-\infty}^{+\infty}}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

%\graphicspath{{figures/}}\begin{document}


\begin{document}
\title{Homework 10}
\author{Zhen}
\maketitle

\section*{Problem 1}

The KKT conditions are:
\[
	\begin{aligned}
		&2x_1+2\mu_1(x_1-1)+2\mu_2(x_1-1)=0
		\\&
		2x_2+2\mu_1(x_2-1)+2\mu_2 x_2=0
		\\&
		\mu_i\ge0,\ i=1,2
		\\&
		\mu_ig_i(\bx)=0,\ i=1,2
	\end{aligned}
\]
\\
\case{1}
$g_2$ is inactive and $g_1$ is active. Then $\mu_2=0$ and $g_1(\bx)=0$.

\[
    \begin{cases}
		x_1=x_2=1-\frac{\sqrt{2}}{2}
		\\
		\mu_1=\sqrt{2}-1
    \end{cases}
	\mbox{or }\ 
	\begin{cases}
		x_1=x_2=1+\frac{\sqrt{2}}{2}
		\\
		\mu_1=-1-\sqrt{2}
    \end{cases}
	\mbox{(contradiction to $\mu_1\ge0$)}
\]
By the sufficiency of KKT conditions for convex problems, $\bx^*=(1-\frac{\sqrt{2}}{2},1-\frac{\sqrt{2}}{2}),\ \mu_1=\sqrt{2}-1,\ \mu_2=0$.
\\
\\
\textcolor{red}{Note that:} this theorem(the sufficiency of KKT conditions for convex problems) will be used for many times. For the sake of convenience we denote it as ``Thm 1''.

\section*{Problem 2}
\begin{enumerate}[(a)]
	\item The feasible set is $\{(x_1,x_2):x_1=1\land x_2=0\}$. Then $\bx^*=(1,0),f^*=1$.
	\item
		The KKT conditions are:
		\[
		    \begin{aligned}
				&2x_1+2\mu_1(x_1-1)+2\mu_2(x_1-1)=0
				\\&
				2x_2+2\mu_1(x_2-1)+2\mu_2(x_2+1)=0
				\\&
				\mu_i\ge0,\ i=1,2
				\\&
				\mu_1[(x_1-1)^2+(x_2-1)^2-1]=0
				\\&
				\mu_2[(x_1-1)^2+(x_2+1)^2-1]=0
	\end{aligned}
		\]
		$x_1=1$ and $x_2=0$ will lead to contradiction. Thus there does not exist Lagrange multipliers  satisfying the KKT conditions and both $g$ are active. 
		\[
			\nabla\bg(\bx^*)=\mqty[0 & 1 \\ 0 & 1]
		\]
		Thus $\bx^*$ is not regular.
\end{enumerate}

\newpage
\section*{Problem 3}
Let
\[
	\bg(\bx^*)
	=\mqty[g_1(\bx^*)\\g_2(\bx^*)\\g_3(\bx^*)\\g_4(\bx^*)]
	=\mqty[x_1^2-x_2 \\ x_1+x_2-6 \\ -x_1 \\ -x_2]
\]
The KKT conditions are:
\[
	\begin{aligned}
		&2(x_1-\frac{9}{4})+2\mu_1x_1+\mu_2-\mu_3=0
		\\&
		2(x_2-2)-\mu_1+\mu_2-\mu_4=0
		\\&
		\mu_i\ge0,\ i=1,2,3,4
		\\&
		\mu_ig_i(\bx)=0,\ i=1,2,3,4
	\end{aligned}
\]
\case{1}
$g_1$ is active and $g_2,g_3,g_4$ are inactive. Then $x_1^2=x_2$ and $\mu_2=\mu_3=\mu_4=0$.

Then we have 
\[
	x_1=\frac{3}{2},\ x_2=\frac{9}{4},\ 
	\mu_1=\frac{1}{2}
\]

By Thm 1 and the fact that $f,\bg$ are convex:
\[
	\bx^*=\mqty[\frac{3}{2} & \frac{9}{4}],\ 
	\mu_1=\frac{1}{2},\ 
	\mu_2=\mu_3=\mu_4=0
\]

\section*{Problem 4}
\begin{enumerate}[(a)]
	\item
		The KKT conditions are:
		\[
			\begin{aligned}
				&\bx-\bz+\lambda\by-\bold{\mu}=0
				\\&
				\by^T\bx=0
				\\&
				\bold{\mu}\ge\bold{0}
				\\&
				\bM\bx=\bold{0}
			\end{aligned}
		\]
		where 
		$
		\lambda\in\RR,\ 
		\mu=(\mu_1,\dots,\mu_n)^T\in\RR,\ 
		\bM=\mbox{diag}(\mu_1,\dots,\mu_n)
		$.
		\\
		Then we have:
		\begin{itemize}
			\item 
				If $x^*_i=0$ and $\mu_i\ge0$, then $x_i=\mu_i+z_i-\lambda y_i=0$ which means that $z_i-\lambda y_i\le0$. Thus $x_i=(z_i-\lambda y_i)^+$.
			\item
				If $\mu_i=0$, then $x_i=z_i-\lambda y_i>0$.
		\end{itemize}
		Thus $x_i=(z_i-\lambda y_i)^+$.
		\\
		And by the fact that $\by^T\bx=0$, 
		$\sum_{i=1}^ny_i(z_i-\lambda y_i)^+$.
	\item
		My code is in the next page 
		(Also in the file ``code.py'').

		The final result is: $\bx^*=(\frac{1}{3},\frac{4}{3},\frac{5}{3})^T$ and $\lambda=\frac{2}{3}$.
		\newpage

\begin{python}
import numpy as np

def solve(z,y):
    """
    compute lamda for a particular optimization problem:
    \min 0.5*\norm{x-z}^2
    s.t. y^Tx = 0
         x >= 0

    Inputs:
    - z: vector in objective function, of shape (N,) or (N,1)
    - y: vector in equality constraint function, of any given shape (N,) or (N,1)

    Returns a tuple of:
    - x: the optimal point of the problem, of shape (N,) or (N,1). x = (z-lamda*y)^+.
    - lamda: the Lagrange multiplier of the equality constraint function in KKT conditions.
    """

    shape = z.shape
    z = z.reshape(-1)
    y = y.reshape(-1)
    # initialize some parameters
    p = np.sum(y>0) # number of the elements > 0 in y
    m = len(y) - p
    u = np.sort(z[y==1]) # u = {z_i: i \in I_+}
    w = np.sort(-z[y==-1])
    u = np.append([-np.inf],u)
    u = np.append(u,[np.inf])
    w = np.append([-np.inf],w)
    w = np.append(w,[np.inf])

    U = np.zeros(p+1)
    W = np.zeros(m+1)
    for i in range(p):
        U[p-i-1] = U[p-i] + u[p-i]
    for i in range(m):
        W[i+1] = W[i] + w[i+1]
    # initialization of lamda, l and k
    lam = -1
    k = 0
    l = 0
    # Nlog(N) algortithm
    while (k<=p) and (l<=m):
        lam = (U[k] + W[l]) / (p - k + l)
        if (u[k] <= lam <= u[k+1]) and (w[l] <= lam <= w[l+1]):
            break
        if  u[k+1] < w[l+1]:
            k = k+1
        else:
            l = l+1
    return (((z - lam * y) > 0) * (z - lam * y)).reshape(shape), lam


z_p4 = np.array([1.0, 2.0, 1.0])
y_p4 = np.array([1.0, 1.0, -1.0])
x,lamda = solve(z_p4, y_p4)
# print(x,lamda)
    
\end{python}
\end{enumerate}




\end{document}

